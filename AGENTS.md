---
AI_CONTEXT: true
VERSION: 0.15.0
LAST_UPDATED: 2025-11-17
CODEBASE_SIZE: ~470 TypeScript files (41 API, 132 App, 299 Packages)
COMPLEXITY: Advanced (Full-stack, Real-time sync, Multi-tenancy)
TECH_STACK: Bun, React 19, Hono, PostgreSQL 17, Electric SQL, TanStack ecosystem
---

# AGENTS.md

This file provides guidance to AI coding assistants when working with code in this repository.

## How to Use This Documentation

1. **First time?** Read "Quick Reference" and "Project Overview" sections below
2. **Adding features?** See "Architecture Patterns" and "Common Tasks" sections
3. **Debugging?** Check "Common Debugging" section
4. **Need component?** See "Component Registry" section

## Quick Reference for AI Agents

### Common Tasks Cheat Sheet

- **Add new API route**: Follow 3-file pattern in `apps/api/src/routes/[resource]/` (index.ts, repository.ts, schema.ts)
- **Add database table**: Update `apps/api/src/db/schema.ts:1-346` → `bun run db:generate` → `bun run db:migrate`
- **Add frontend route**: Create file in `apps/app/src/routes/` (file-based routing with TanStack Router)
- **Add UI component**: Place in `apps/app/src/components/` or `packages/ui/src/components/` if reusable
- **Add collection**: Create in `apps/app/src/lib/collections/[resource].ts` with Electric SQL
- **Debug sync**: Check `http://localhost:4000/health`, verify PostgreSQL WAL level is "logical"
- **Fix type errors**: Restart dev servers to regenerate RPC types and route definitions

### File Location Quick Lookup

| What | Where | Lines |
|------|-------|-------|
| Database schema | `apps/api/src/db/schema.ts` | 346 |
| API client types | `apps/app/src/lib/api-client.ts` | 313 |
| Frontend schemas | `apps/app/src/lib/schema.ts` | 111 |
| Expense API routes | `apps/api/src/routes/expenses/` | 3 files (index, repository, schema) |
| Expense components | `apps/app/src/components/expenses/` | 6 files |
| Expense live queries | `apps/app/src/components/expenses/use-expenses.ts` | 253 |
| Category components | `apps/app/src/components/categories/` | 3 files |
| Wallet components | `apps/app/src/components/wallets/` | 2 files |
| Auth setup | `apps/api/src/lib/auth.ts` | - |
| Sync proxy | `apps/api/src/modules/sync.ts` | - |
| PGlite provider | `apps/app/src/components/providers/local-postgres-provider.tsx` | - |
| Collections | `apps/app/src/lib/collections/*.ts` | - |
| Query options | `apps/app/src/services/query-options.ts` | - |
| Mutations | `apps/app/src/services/mutations.ts` | - |

### Critical Constraints

**NEVER do these:**
- ❌ Modify `apps/app/src/lib/api-client.ts` - auto-generated from Hono RPC
- ❌ Edit `apps/app/src/routeTree.gen.ts` - generated by TanStack Router
- ❌ Use relative imports like `../../` - use path aliases instead
- ❌ Omit `.ts`/`.tsx` extensions in imports - Bun requirement
- ❌ Skip migrations after schema changes - data loss risk
- ❌ Modify database directly without migrations - Electric SQL will break
- ❌ Create routes without workspace scoping - security issue

**ALWAYS do these:**
- ✅ Use path aliases (`#app/*`, `#api/*`) instead of relative imports
- ✅ Include `.ts`/`.tsx` extensions in all imports (Bun requirement)
- ✅ Run migrations after schema changes: `db:generate` → `db:migrate`
- ✅ Validate with Zod before database operations
- ✅ Scope all data by `workspace_id` foreign key (multi-tenancy)
- ✅ Use middleware chain: `workspaceQueryValidator` → `workspaceMember` → handler
- ✅ Return typed results from repository functions
- ✅ Include OpenAPI documentation for all API routes
- ✅ Use `z.coerce.number()` for Electric SQL numeric fields
- ✅ Restart dev servers after API changes to regenerate types

### Component Registry

#### API Routes (`apps/api/src/routes/`)

| Resource | Files | Endpoints | Repository Methods |
|----------|-------|-----------|-------------------|
| **categories** | index.ts, repository.ts, schema.ts | GET /, GET /:id, POST /, PATCH /:id, DELETE /:id | findAllByWorkspaceId, findOne, insert, update, delete |
| **expenses** | index.ts, repository.ts, schema.ts | GET /, GET /:id, POST /, PATCH /:id, DELETE /:id | findAllByWorkspaceId, findOne, insert, update, delete |
| **wallets** | index.ts, repository.ts, schema.ts | GET /, GET /:id, POST /, PATCH /:id, DELETE /:id | findAllByWorkspaceId, findOne, insert, update, delete |
| **tasks** | index.ts, repository.ts, schema.ts | GET /, GET /:id, POST /, PATCH /:id, DELETE /:id | findAllByWorkspaceId, findOne, insert, update, delete |
| **files** | index.ts, repository.ts, schema.ts | GET /, POST /, DELETE /:id | findAllByWorkspaceId, upload, delete |
| **exchange-rates** | index.ts, repository.ts, schema.ts | GET /, POST / | findAll, insertMany |

#### Frontend Components (`apps/app/src/components/`)

**Expenses (6 files):**
- `expense-list.tsx` - Virtualized list with TanStack Virtual
- `expense-content.tsx` - Individual list item component
- `expense-details.tsx` - Detail panel with edit/delete actions
- `expense-actions.tsx` - Create/Edit dialog triggers
- `expense-filter.tsx` - Filter controls (search, category, wallet, repeat)
- `use-expenses.ts` (253 lines) - Live queries, stats calculations, filtering logic

**Categories (3 files):**
- `categories-table.tsx` - Table view with sorting
- `category-actions.tsx` - CRUD actions
- `use-categories.ts` - Live queries and transformations

**Wallets (2 files):**
- `wallet-actions.tsx` - CRUD operations
- `wallet-badge.tsx` - Display component

**Forms (16 files):**
- `form.tsx` - TanStack Form wrapper with validation
- `input.tsx`, `select.tsx`, `switch.tsx` - Basic form inputs
- `datepicker.tsx`, `datepicker-input.tsx` - Date selection
- `transaction-amount.tsx` - Currency input with formatting
- `select-category.tsx`, `select-with-search.tsx` - Enhanced select components
- `tiptap.tsx` - Rich text editor (TipTap v3.10+)
- `files.tsx` - File upload with drag-drop
- `color.tsx` - Color picker for categories

**Charts (5 files):**
- `expense-stats-row.tsx` - Summary cards with percentage changes
- `expenses-overview.tsx` - Line/area chart with Recharts
- `category-breakdown.tsx` - Pie/donut chart for categories
- `date-range-picker.tsx` - Date range selector component
- `dashboard-date-filter.tsx` - Quick date filters (today, week, month, year)

**Providers (5 files):**
- `local-postgres-provider.tsx` - PGlite setup with IndexedDB (idb://hoalu-db)
- `dialog-provider.tsx` - Global dialog state management
- `ui-provider.tsx` - Theme provider and toast notifications
- `workspace-action-provider.tsx` - Workspace context menu actions
- `dashboard-action-provider.tsx` - Dashboard-level actions

**Layouts (14 files):**
- Responsive layouts, sidebars, navigation, page content wrappers

#### Shared UI Components (`packages/ui/src/components/`)

37 shadcn/ui based components: accordion, alert, avatar, badge, button, card, checkbox, combobox, dialog, dropdown-menu, form, input, label, popover, radio-group, scroll-area, select, separator, sheet, skeleton, switch, table, tabs, textarea, toast, tooltip, etc.

### Architecture Decision Records

#### Why Electric SQL for Real-time Sync?
**Status:** Accepted
**Decision:** Use Electric SQL + PGlite for offline-first, real-time data synchronization
**Rationale:**
- True offline-first capability with PostgreSQL in browser (PGlite)
- Logical replication from PostgreSQL provides automatic sync
- No manual sync logic needed - Electric handles conflict resolution
- Reactive queries with TanStack DB Collections
- Automatic reactivity when data changes

**Consequences:**
- ✅ Offline-first without complex sync code
- ✅ Real-time updates across clients
- ✅ Automatic conflict resolution
- ❌ Requires PostgreSQL WAL level=logical
- ❌ Electric SQL service dependency (port 4000)

**Implementation:**
- PostgreSQL (WAL) → Electric SQL (port 4000) → API Proxy (`/sync` with auth) → PGlite (IndexedDB) → React

#### Why Turborepo Monorepo?
**Status:** Accepted
**Decision:** Use Turborepo with Bun workspaces for monorepo management
**Rationale:**
- Multiple apps (api, app, web) share code (auth, ui, common, etc.)
- Workspace catalog ensures version consistency
- Turborepo provides efficient build caching
- Path aliases (`#app/*`, `#api/*`) simplify imports

**Structure:**
- Apps in `/apps` (api, app, web)
- Shared packages in `/packages` (9 packages)
- 3-file route pattern for consistency (index, repository, schema)

#### Why Hono over Express/Fastify?
**Status:** Accepted
**Decision:** Use Hono v4.10+ as backend framework
**Rationale:**
- Lightweight and fast (built for edge/Bun)
- TypeScript-first with excellent type inference
- Built-in OpenAPI support via hono-openapi
- RPC client generates types for frontend automatically

**Benefits:**
- End-to-end type safety (API → Frontend)
- Auto-generated API documentation with Scalar
- Middleware chaining similar to Express
- Works seamlessly with Bun runtime

## Project Overview

**Hoalu** is a modern expense tracking and workspace management application built as a monorepo using Bun and Turbo. It features real-time synchronization, multi-workspace support, offline-first architecture, and a comprehensive API.

**Version**: 0.15.0
**Package Manager**: Bun
**Build System**: Turborepo

## Tech Stack

### Frontend (@hoalu/app)

- **Framework**: React 19 with React DOM 19
- **Routing**: TanStack Router v1.134+ with file-based routing
- **Data Fetching**: TanStack Query v5.90+ with TanStack React DB v0.1+
- **Forms**: TanStack Form v1.23+ with Zod v4 validation
- **State Management**: Jotai v2.15+ atoms for local state
- **Real-time Sync**:
  - Electric SQL with `@electric-sql/pglite` v0.3+
  - `@tanstack/electric-db-collection` for reactive collections
  - PGlite Sync for offline-first PostgreSQL in browser
- **Styling**:
  - TailwindCSS v4.1+ with `@tailwindcss/vite`
  - shadcn/ui and base-ui components via `@hoalu/ui`
  - `class-variance-authority` for component variants
- **UI Components**:
  - TipTap v3.10+ for rich text editing
  - Recharts v3.3+ for data visualization
  - TanStack Table v8.21+ and Virtual v3.13+ for lists
- **PWA**: Vite PWA plugin with workbox strategies
- **Dev Tools**: React Query DevTools, Router DevTools, Form DevTools
- **Build Tool**: Vite with SWC for fast compilation
- **Hotkeys**: react-hotkeys-hook v5.2+

### Backend (@hoalu/api)

- **Framework**: Hono v4.10+ (lightweight web framework)
- **Runtime**: Bun (Node.js alternative)
- **Database**: PostgreSQL 17 with Drizzle ORM v0.44+
- **Authentication**: Better Auth v1.3+ with custom workspace plugin
- **Validation**:
  - Zod v4 for schema validation
  - `@hono/zod-validator` and `@hono/standard-validator`
  - `hono-openapi` for OpenAPI generation
- **API Documentation**: Scalar via `@scalar/hono-api-reference`
- **Email**:
  - React Email for templates
  - Nodemailer v7 for sending
  - `@react-email/render` for HTML generation
- **Storage**:
  - Redis (ioredis v5.8+) for caching and sessions
  - PostgreSQL (pg v8.16+) as primary database
- **Schema Management**: Drizzle Kit v0.31+ for migrations

### Infrastructure

- **Build System**: Turborepo with Bun workspaces
- **Database**:
  - PostgreSQL 17 with logical replication (WAL level)
  - Drizzle ORM with migration-first workflow
- **Real-time Sync**: Electric SQL sync engine on port 4000
- **Caching**: Redis for rate limiting, sessions, and temporary data
- **Reverse Proxy**: Caddy v2+ for development proxy server
  - Automatic HTTPS with self-signed certificates for localhost (when using https:// scheme)
  - HTTP/2 and HTTP/3 support enabled by default on HTTPS connections
  - Gzip compression for all responses
  - Simple reverse proxy configuration
- **Containerization**: Docker Compose for local development
  - `docker-compose.local.yml` - Local development
  - `docker-compose.infra.yml` - Infrastructure services
  - `docker-compose.platform.yml` - Platform deployment

#### Reverse Proxy with Caddy

**Port Architecture:**

```
Development Setup:
  Browser → hoalu.localhost (Caddy) → localhost:5173 (Vite dev server)
  Browser → api.hoalu.localhost (Caddy) → localhost:3000 (Hono API)

Internal Services:
  - Vite dev server: localhost:5173 (HTTP, not directly accessible)
  - Hono API server: localhost:3000 (HTTP, not directly accessible)
  - Electric SQL: localhost:4000 (HTTP, proxied through API `/sync`)
  - PostgreSQL: localhost:5432 (internal)
  - Redis: localhost:6379 (internal)

Public-facing (via Caddy):
  - Frontend: http://hoalu.localhost (HTTP by default, HTTPS optional)
  - API: http://api.hoalu.localhost (HTTP by default, HTTPS optional)
```

**Current Caddyfile Configuration (`/Caddyfile`):**

```caddy
api.hoalu.localhost {
	reverse_proxy localhost:3000
	encode gzip
}

hoalu.localhost {
	reverse_proxy localhost:5173
	encode gzip
}
```

**HTTPS Configuration (Optional):**

To enable HTTPS with automatic TLS certificates, prefix addresses with `https://`:

```caddy
# API proxy with HTTPS and HTTP/2
https://api.hoalu.localhost {
	# Handle CORS preflight requests
	@options {
		method OPTIONS
	}
	handle @options {
		header {
			Access-Control-Allow-Origin "https://hoalu.localhost"
			Access-Control-Allow-Methods "GET, POST, PUT, DELETE, PATCH, OPTIONS, HEAD"
			Access-Control-Allow-Headers "Content-Type, Authorization, Cookie"
			Access-Control-Allow-Credentials "true"
			Access-Control-Max-Age "86400"
		}
		respond 204
	}

	# Add CORS headers to all responses
	header {
		Access-Control-Allow-Origin "https://hoalu.localhost"
		Access-Control-Allow-Credentials "true"
	}

	reverse_proxy localhost:3000 {
		header_up Host {host}
		header_up X-Real-IP {remote_host}
	}

	encode gzip
}

# Frontend proxy with HTTPS and HTTP/2
https://hoalu.localhost {
	reverse_proxy localhost:5173
	encode gzip
}
```

**Running Caddy:**

```bash
# Run Caddy from project root
caddy run

# Or run in background
caddy start

# Reload configuration without downtime
caddy reload

# Stop Caddy
caddy stop

# Validate Caddyfile syntax
caddy validate --config Caddyfile
```

**Caddy Features:**

- **Automatic TLS**: When using `https://` scheme, Caddy auto-generates self-signed certificates for localhost
- **HTTP/2**: Automatically enabled for HTTPS connections
- **HTTP/3**: Enabled by default (QUIC protocol)
- **Compression**: Gzip encoding applied to all proxied responses
- **Custom Local Domains**: Uses `.localhost` TLDs which work without `/etc/hosts` modification
- **Zero Config**: Works out of the box with minimal configuration

**Benefits:**

- ✅ Custom local domains (hoalu.localhost) instead of port-based URLs
- ✅ No need to modify `/etc/hosts` - `.localhost` domains work natively
- ✅ Clean, production-like URLs in development
- ✅ Gzip compression reduces bandwidth usage
- ✅ Optional HTTPS support for production-like development
- ✅ HTTP/2 multiplexing when using HTTPS
- ✅ Matches production deployment architecture
- ✅ Single proxy point for frontend and API
- ✅ Easy to add features like rate limiting, caching, or load balancing

## Monorepo Structure

```
hoalu/
├── apps/
│   ├── api/              # Backend Hono API
│   │   ├── src/
│   │   │   ├── db/       # Drizzle schema and connection
│   │   │   ├── lib/      # Auth, Redis, S3, Email utilities
│   │   │   ├── middlewares/  # User session, workspace member
│   │   │   ├── modules/  # API, Auth, OpenAPI, Sync modules
│   │   │   ├── routes/   # CRUD routes (categories, expenses, etc.)
│   │   │   ├── utils/    # Constants, I/O, monetary helpers
│   │   │   └── validators/  # Request validators
│   │   └── migrations/   # Drizzle database migrations
│   │
│   ├── app/              # Frontend React application
│   │   ├── src/
│   │   │   ├── atoms/    # Jotai state atoms
│   │   │   ├── components/  # React components
│   │   │   │   ├── charts/     # Data visualization
│   │   │   │   ├── expenses/   # Expense-specific components
│   │   │   │   ├── forms/      # Form components with TanStack Form
│   │   │   │   ├── layouts/    # Layout components
│   │   │   │   ├── providers/  # Context providers
│   │   │   │   └── wallets/    # Wallet components
│   │   │   ├── helpers/  # Utility functions
│   │   │   ├── hooks/    # Custom React hooks
│   │   │   ├── lib/      # Core libraries
│   │   │   │   ├── collections/  # TanStack DB collections
│   │   │   │   ├── api-client.ts
│   │   │   │   ├── query-key-factory.ts
│   │   │   │   └── schema.ts
│   │   │   ├── routes/   # TanStack Router routes
│   │   │   │   ├── _auth/      # Auth routes
│   │   │   │   └── _dashboard/ # Dashboard routes
│   │   │   ├── services/ # API queries and mutations
│   │   │   └── styles/   # Global styles
│   │   └── public/       # Static assets
│   │
│   └── web/              # Reserved for future web app
│
├── packages/
│   ├── auth/             # Better Auth plugins & workspace management
│   ├── common/           # Shared utilities, enums, validation schemas
│   ├── countries/        # Country, currency, language data
│   ├── email/            # React Email templates
│   ├── furnace/          # Hono server utilities & middleware
│   ├── icons/            # Icon libraries (Lucide, Meteocons, Nucleo, Tabler)
│   ├── themes/           # TailwindCSS theme configurations
│   ├── tsconfig/         # Shared TypeScript configurations
│   └── ui/               # Shared UI components (shadcn/ui based)
│
├── deployments/          # Docker and deployment configs
│   ├── scripts/          # Deployment scripts
│   └── *.Dockerfile      # Container definitions
│
└── package.json          # Root workspace config with catalog
```

### Applications (`/apps`)

#### `@hoalu/api` - Backend API

- **Path Alias**: `#api/*` maps to `./src/*`
- **Build**: Bun bundler for production, TypeScript for type definitions
- **Main Entry**: `src/index.ts`
- **Key Files**:
  - `src/app.ts` - Hono app configuration
  - `src/db/schema.ts` - Drizzle database schema (346 lines)
  - `src/db/index.ts` - Database connection
  - `src/lib/auth.ts` - Better Auth setup
  - `src/modules/sync.ts` - Electric SQL sync proxy

#### `@hoalu/app` - Frontend Application

- **Path Alias**: `#app/*` maps to `./src/*`
- **Build**: Vite with React SWC plugin
- **Main Entry**: `src/main.tsx`
- **Key Files**:
  - `src/lib/api-client.ts` - Hono RPC client (8105 lines)
  - `src/lib/schema.ts` - Frontend type definitions (3127 lines)
  - `src/hooks/use-db.ts` - TanStack DB live queries
  - `src/services/query-options.ts` - Reusable query configs
  - `src/services/mutations.ts` - Mutation configurations

### Packages (`/packages`)

#### Core Packages

- **@hoalu/auth** - Better Auth workspace plugin
- **@hoalu/common** - Shared utilities (`datetime`, `monetary`, `schema`, `enums`)
- **@hoalu/countries** - Country/currency data with helpers
- **@hoalu/email** - React Email templates (join-workspace, reset-password, verify-email)
- **@hoalu/furnace** - Hono utilities (error handlers, auth guards, CORS, OpenAPI)
- **@hoalu/icons** - Unified icon exports from multiple libraries
- **@hoalu/themes** - TailwindCSS color themes and base styles
- **@hoalu/tsconfig** - Shared TypeScript configs (base, app, bun, vite)
- **@hoalu/ui** - shadcn/ui components with customizations

## Development Workflow

### Getting Started

```bash
# Install Bun if not already installed
curl -fsSL https://bun.sh/install | bash

# Install Caddy if not already installed (macOS)
brew install caddy

# Install dependencies
bun install

# Start local infrastructure (PostgreSQL, Redis, Electric)
bun run docker:up

# Start Caddy reverse proxy (in project root)
caddy run

# Start development servers (API + App)
bun run dev
```

### Key Commands

**Root Level:**

- `bun run build` - Build all packages and apps (via Turbo)
- `bun run dev` - Start dev servers for all apps
- `bun run docker:up` - Start Docker infrastructure
- `bun run docker:down` - Stop Docker infrastructure

**Caddy:**

```bash
# Start Caddy reverse proxy
caddy run                 # Run in foreground
caddy start               # Run in background
caddy reload              # Reload configuration
caddy stop                # Stop Caddy server
caddy validate            # Validate Caddyfile syntax
```

**API (@hoalu/api):**

```bash
cd apps/api

# Database
bun run db:generate    # Generate Drizzle migrations
bun run db:migrate     # Apply migrations

# Development
bun run dev           # Start API dev server with auto-reload
bun run build         # Build API and type definitions
bun run clean         # Clean build artifacts
```

**App (@hoalu/app):**

```bash
cd apps/app

# Development
bun run dev           # Start Vite dev server
bun run dev:pwa       # Start with PWA dev mode
bun run build         # Build for production
bun run preview       # Preview production build
```

### Database Management

```bash
# From apps/api directory
bun run db:generate   # Create migration from schema changes
bun run db:migrate    # Apply pending migrations

# Pull production database (deployment script)
./deployments/scripts/pull-db.sh
```

## Architecture Patterns

### API Routes Structure (`apps/api/src/routes/`)

Each entity (categories, expenses, wallets, tasks, files, exchange-rates) follows a consistent three-file pattern:

**1. `index.ts` - Route Handlers with OpenAPI**

```typescript
import { createHonoApp } from "@hoalu/furnace";
import { workspaceQueryValidator } from "#api/validators/workspace-query.ts";
import { workspaceMember } from "#api/middlewares/workspace-member.ts";
import * as repository from "./repository.ts";
import * as schema from "./schema.ts";

const app = createHonoApp();

// GET /api/expenses?workspaceId=xxx
app.get("/", workspaceQueryValidator, workspaceMember, async (c) => {
  const { workspaceId } = c.var.workspace;
  const expenses = await repository.findMany(workspaceId);
  return c.json({ data: expenses });
});

// POST /api/expenses
app.post("/", jsonBodyValidator(schema.CreateExpenseSchema), async (c) => {
  // Handler implementation
});

export default app;
```

**2. `repository.ts` - Database Operations**

```typescript
import { db } from "#api/db/index.ts";
import { expense, wallet, category } from "#api/db/schema.ts";
import { eq, desc } from "drizzle-orm";

export async function findMany(workspaceId: string) {
  return db
    .select()
    .from(expense)
    .where(eq(expense.workspaceId, workspaceId))
    .orderBy(desc(expense.date));
}

export async function create(data: InsertExpense) {
  return db.insert(expense).values(data).returning();
}
```

**3. `schema.ts` - Zod Validation Schemas**

```typescript
import * as z from "zod";
import { CurrencySchema, RepeatSchema } from "@hoalu/common/schema";

export const CreateExpenseSchema = z.object({
  title: z.string().min(1),
  amount: z.coerce.number(),
  currency: CurrencySchema,
  repeat: RepeatSchema,
  // ...
});

export const UpdateExpenseSchema = CreateExpenseSchema.partial();
```

**Middleware Flow:**

```
Request
  → workspaceQueryValidator (validates ?workspaceId)
  → workspaceMember (checks user is member)
  → handler (executes business logic)
  → response
```

### Frontend Architecture (`apps/app/src/`)

#### Path Aliases

```typescript
// Use #app/* for all imports
import { useAuth } from "#app/hooks/use-auth.ts";
import { apiClient } from "#app/lib/api-client.ts";
import { ExpenseFormSchema } from "#app/lib/schema.ts";
```

#### Component Organization

```
components/
├── charts/           # Data visualization components
│   ├── expense-stats-row.tsx
│   ├── expenses-overview.tsx
│   ├── category-breakdown.tsx
│   └── date-range-picker.tsx
│
├── expenses/         # Expense-specific components
│   ├── expense-list.tsx      # Virtualized list
│   ├── expense-content.tsx   # List item component
│   ├── expense-details.tsx   # Detail view
│   ├── expense-actions.tsx   # Action buttons
│   └── expense-filter.tsx    # Filter controls
│
├── forms/            # Form components with TanStack Form
│   ├── form.tsx              # Base form wrapper
│   ├── input.tsx             # Text inputs
│   ├── select.tsx            # Select dropdowns
│   ├── datepicker.tsx        # Date picker
│   ├── transaction-amount.tsx # Currency input
│   └── files.tsx             # File upload
│
├── layouts/          # Layout components
├── providers/        # React context providers
│   ├── ui-provider.tsx
│   ├── dialog-provider.tsx
│   ├── local-postgres-provider.tsx
│   └── workspace-action-provider.tsx
│
└── wallets/          # Wallet components
```

#### State Management with Jotai

**Location**: `apps/app/src/atoms/`

```typescript
// atoms/expenses.ts
import { atom } from "jotai";

export const draftExpenseAtom = atom<Partial<ExpenseFormSchema> | null>(null);
export const selectedExpenseAtom = atom<string | null>(null);

// atoms/dialogs.ts
export const expenseDialogAtom = atom(false);
export const categoryDialogAtom = atom(false);

// atoms/filters.ts
export const dateRangeAtom = atom<{ from: Date; to: Date } | null>(null);
```

**Usage Pattern:**

```typescript
import { useAtom } from "jotai";
import { selectedExpenseAtom } from "#app/atoms/expenses.ts";

function ExpenseList() {
  const [selectedId, setSelectedId] = useAtom(selectedExpenseAtom);
  // ...
}
```

#### Data Layer - TanStack Query + DB

**Collections** (`lib/collections/`):

```typescript
// lib/collections/expense.ts
import { electricCollectionOptions } from "@tanstack/electric-db-collection";
import { createCollection } from "@tanstack/react-db";
import * as z from "zod";

const SelectExpenseSchema = z.object({
  id: z.uuidv7(),
  title: z.string(),
  amount: z.coerce.number(), // Coerces string to number
  currency: CurrencySchema,
  date: IsoDateSchema,
  wallet_id: z.uuidv7(),
  category_id: z.uuidv7(),
  // ...
});

export const expenseCollection = (workspaceId: string) => {
  return createCollection(
    electricCollectionOptions({
      getKey: (item) => item.id,
      schema: SelectExpenseSchema,
      shapeOptions: {
        url: `${import.meta.env.PUBLIC_API_URL}/sync`,
        params: {
          table: "expense",
          where: "workspace_id = $1",
          params: [workspaceId],
        },
        fetchClient: (req, init) =>
          fetch(req, { ...init, credentials: "include" }),
      },
    })
  );
};
```

**Live Queries** (`hooks/use-db.ts`):

```typescript
import { useLiveQuery, eq } from "@tanstack/react-db";
import { datetime } from "@hoalu/common/datetime";
import { monetary } from "@hoalu/common/monetary";

export function useExpenseLiveQuery() {
  const workspace = useWorkspace();

  // Query with joins
  const { data: expenses } = useLiveQuery((q) =>
    q
      .from({ expense: expenseCollection(workspace.id) })
      .innerJoin(
        { wallet: walletCollection(workspace.id) },
        ({ expense, wallet }) => eq(expense.wallet_id, wallet.id)
      )
      .leftJoin(
        { category: categoryCollection(workspace.id) },
        ({ expense, category }) => eq(expense.category_id, category.id)
      )
      .orderBy(({ expense }) => expense.date, "desc")
      .select(({ expense, wallet, category }) => ({
        ...expense,
        category: {
          id: category?.id,
          name: category?.name,
          description: category?.description,
          color: category?.color,
        },
        wallet: {
          id: wallet.id,
          name: wallet.name,
          description: wallet.description,
          currency: wallet.currency,
          type: wallet.type,
          isActive: wallet.is_active,
        },
      }))
  );

  // Transform for presentation layer
  return useMemo(() => {
    if (!expenses) return [];

    return expenses.map((expense) => ({
      ...expense,
      date: datetime.format(expense.date, "yyyy-MM-dd"),
      amount: monetary.fromRealAmount(Number(expense.amount), expense.currency),
      realAmount: Number(expense.amount),
      convertedAmount: Number(expense.amount),
    }));
  }, [expenses]);
}

export type ExpensesClient = ReturnType<typeof useExpenseLiveQuery>;
export type ExpenseClient = ExpensesClient[number];
```

**Query Options** (`services/query-options.ts`):

```typescript
import { queryOptions } from "@tanstack/react-query";
import { apiClient } from "#app/lib/api-client.ts";

export const getExpensesQueryOptions = (workspaceId: string) =>
  queryOptions({
    queryKey: ["expenses", workspaceId],
    queryFn: async () => {
      const res = await apiClient.api.expenses.$get({
        query: { workspaceId },
      });
      if (!res.ok) throw new Error("Failed to fetch expenses");
      const { data } = await res.json();
      return data;
    },
  });
```

**Mutations** (`services/mutations.ts`):

```typescript
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "#app/lib/api-client.ts";

export function useCreateExpense() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: ExpensePostSchema) => {
      const res = await apiClient.api.expenses.$post({ json: data });
      if (!res.ok) throw new Error("Failed to create expense");
      return res.json();
    },
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({
        queryKey: ["expenses", variables.workspaceId],
      });
    },
  });
}
```

#### Routing with TanStack Router

**File-based Routes:**

```
routes/
├── _auth/               # Auth layout
│   ├── login.tsx
│   ├── register.tsx
│   └── route.tsx        # Auth layout wrapper
│
├── _dashboard/          # Dashboard layout
│   ├── $slug/           # Workspace routes
│   │   ├── expenses.tsx
│   │   ├── categories.tsx
│   │   ├── wallets.tsx
│   │   └── settings/
│   │       ├── general.tsx
│   │       ├── members.tsx
│   │       └── billing.tsx
│   ├── account/         # User account
│   │   ├── preferences.tsx
│   │   └── tokens.tsx
│   ├── index.tsx        # Workspace list
│   └── route.tsx        # Dashboard layout
│
└── index.tsx            # Home/landing
```

**Route Protection:**

```typescript
// routes/_dashboard/route.tsx
export const Route = createFileRoute("/_dashboard")({
  beforeLoad: async ({ context }) => {
    const { session } = await context.auth.getSession();
    if (!session) {
      throw redirect({ to: "/login" });
    }
  },
});
```

### Real-time Synchronization

#### Electric SQL Architecture

**Flow:**

```
PostgreSQL (WAL)
  → Electric SQL Sync Engine (port 4000)
  → API Sync Proxy (/sync endpoint with auth)
  → PGlite in Browser (offline storage)
  → TanStack DB Collections (reactive queries)
  → React Components
```

**Sync Proxy** (`apps/api/src/modules/sync.ts`):

```typescript
import { createHonoApp } from "@hoalu/furnace";

const app = createHonoApp();

app.all("/sync/*", async (c) => {
  const session = await getSession(c);
  if (!session) {
    return c.json({ error: "Unauthorized" }, 401);
  }

  // Proxy to Electric with authentication
  const syncUrl = new URL(`${env.SYNC_URL}${c.req.path}`);
  return fetch(syncUrl, {
    method: c.req.method,
    headers: c.req.raw.headers,
    body: c.req.raw.body,
  });
});
```

**PGlite Provider** (`components/providers/local-postgres-provider.tsx`):

```typescript
import { PGliteProvider } from "@electric-sql/pglite-react"
import { electricSync } from "@electric-sql/pglite-sync"

export function LocalPostgresProvider({ children }) {
  const db = usePGlite({
    dataDir: "idb://hoalu-db",
    extensions: { electric: electricSync() },
  })

  return <PGliteProvider db={db}>{children}</PGliteProvider>
}
```

**Collection Sync:**

```typescript
// Collections automatically sync via Electric shapes
const expenseCollection = createCollection(
  electricCollectionOptions({
    shapeOptions: {
      url: `${API_URL}/sync`, // Proxied to Electric
      params: {
        table: "expense",
        where: "workspace_id = $1",
        params: [workspaceId],
      },
    },
    schema: SelectExpenseSchema,
  })
);

// Live queries subscribe to changes
const { data } = useLiveQuery((q) =>
  q.from({ expense: expenseCollection(workspaceId) })
);
// Data updates automatically when DB changes!
```

### Authentication & Authorization

#### Better Auth Setup

**Server** (`apps/api/src/lib/auth.ts`):

```typescript
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { workspacePlugin } from "@hoalu/auth/plugins/workspace";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg",
  }),
  plugins: [
    workspacePlugin({
      // Custom workspace management
      createWorkspaceOnSignup: true,
      roleHierarchy: ["owner", "admin", "member"],
    }),
  ],
  session: {
    expiresIn: 60 * 60 * 24 * 7, // 7 days
    updateAge: 60 * 60 * 24, // 1 day
  },
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: true,
  },
});
```

**Client** (`apps/app/src/lib/auth-client.ts`):

```typescript
import { createAuthClient } from "better-auth/react";

export const authClient = createAuthClient({
  baseURL: import.meta.env.PUBLIC_API_URL,
});

export const { useSession, signIn, signOut } = authClient;
```

**Middleware** (`apps/api/src/middlewares/workspace-member.ts`):

```typescript
export const workspaceMember = createMiddleware(async (c, next) => {
  const session = c.var.session;
  const { workspaceId } = c.var.workspace;

  const member = await db
    .select()
    .from(memberTable)
    .where(
      and(
        eq(memberTable.workspaceId, workspaceId),
        eq(memberTable.userId, session.userId)
      )
    )
    .limit(1);

  if (!member.length) {
    return c.json({ error: "Not a workspace member" }, 403);
  }

  c.set("member", member[0]);
  await next();
});
```

#### Workspace Management

**Multi-tenancy Pattern:**

- All data scoped by `workspace_id` foreign key
- Slug-based routing: `/dashboard/:slug/expenses`
- Member roles: `owner`, `admin`, `member`
- Invitation system with expiration

**Workspace Context:**

```typescript
// hooks/use-workspace.ts
export function useWorkspace() {
  const params = Route.useParams(); // TanStack Router
  const { data: workspace } = useSuspenseQuery(
    getWorkspaceQueryOptions(params.slug)
  );
  return workspace;
}
```

### Database Schema

#### Schema Overview (`apps/api/src/db/schema.ts`)

**Auth Tables (Better Auth):**

- `user` - User accounts with public IDs
- `session` - Active sessions
- `account` - OAuth provider accounts
- `verification` - Email verification tokens
- `jwks` - JSON Web Key Set

**Workspace Tables:**

- `workspace` - Multi-tenant workspaces
- `member` - Workspace membership with roles
- `invitation` - Pending workspace invitations
- `apikey` - API keys for programmatic access

**Core Tables:**

- `category` - Expense categories (name, color, workspace)
- `wallet` - Wallets/accounts (name, type, currency, workspace)
- `expense` - Expenses (amount, date, category, wallet, workspace)
- `file` - File attachments (S3 storage)
- `task` - Task management (title, status, priority, workspace)
- `fx_rate` - Exchange rates (from/to currency, rate, valid dates)

**Enums:**

```typescript
export const colorTypeEnum = pgEnum("color_enum", [
  "gray",
  "red",
  "orange",
  "yellow",
  "green",
  "blue",
  "indigo",
  "purple",
  "pink",
]);

export const walletTypeEnum = pgEnum("wallet_type_enum", [
  "cash",
  "bank",
  "credit_card",
  "digital_wallet",
  "investment",
]);

export const repeatEnum = pgEnum("repeat_enum", [
  "none",
  "daily",
  "weekly",
  "monthly",
  "yearly",
]);

export const taskStatusEnum = pgEnum("task_status_enum", [
  "todo",
  "in_progress",
  "done",
  "cancelled",
]);

export const priorityEnum = pgEnum("priority_enum", [
  "low",
  "medium",
  "high",
  "urgent",
]);
```

**Key Patterns:**

```typescript
// UUID primary keys
id: uuid("id").primaryKey();

// Public IDs for external references
publicId: text("public_id").notNull().unique();

// Workspace scoping
workspaceId: uuid("workspace_id")
  .notNull()
  .references(() => workspace.id, { onDelete: "cascade" });

// Timestamps
createdAt: timestamp("created_at").notNull();
updatedAt: timestamp("updated_at").notNull();

// JSONB for flexible metadata
metadata: jsonb("metadata").$type<Record<string, any>>().default({});

// Numeric for precise decimals
amount: numeric("amount", { precision: 18, scale: 2 }).notNull();

// Full-text search indexes
index("expense_title_idx").using(
  "gin",
  sql`to_tsvector('english', ${expense.title})`
);

// GIN indexes for JSONB
index("workspace_metadata_idx").using("gin", table.metadata);
```

#### Example Schema Definition

```typescript
export const expense = pgTable(
  "expense",
  {
    id: uuid("id").primaryKey(),
    title: text("title").notNull(),
    description: text("description"),
    amount: numeric("amount", { precision: 18, scale: 2 }).notNull(),
    currency: varchar("currency", { length: 3 }).notNull(),
    date: date("date", { mode: "string" }).notNull(),
    repeat: repeatEnum().default("none").notNull(),

    // Foreign keys
    workspaceId: uuid("workspace_id")
      .notNull()
      .references(() => workspace.id, { onDelete: "cascade" }),
    walletId: uuid("wallet_id")
      .notNull()
      .references(() => wallet.id, { onDelete: "cascade" }),
    categoryId: uuid("category_id").references(() => category.id, {
      onDelete: "set null",
    }),
    creatorId: uuid("creator_id")
      .notNull()
      .references(() => user.id),

    // Timestamps
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    index("expense_workspace_id_idx").on(table.workspaceId),
    index("expense_date_idx").on(table.date),
    index("expense_wallet_id_idx").on(table.walletId),
    index("expense_category_id_idx").on(table.categoryId),
    index("expense_title_search_idx").using(
      "gin",
      sql`to_tsvector('english', ${table.title})`
    ),
  ]
);
```

## Code Conventions

### Import Organization (Biome)

```typescript
// 1. Node/Bun built-in modules
import { readFile } from "node:fs/promises";
import path from "node:path";

// 2. External npm packages (alphabetical)
import { queryOptions } from "@tanstack/react-query";
import { eq, desc } from "drizzle-orm";
import { hc } from "hono/client";
import * as z from "zod";

// 3. @hoalu workspace packages (alphabetical)
import { datetime } from "@hoalu/common/datetime";
import { HTTPStatus } from "@hoalu/common/http-status";
import { monetary } from "@hoalu/common/monetary";
import { CurrencySchema } from "@hoalu/common/schema";

// 4. Local imports using path alias (alphabetical)
import { apiClient } from "#app/lib/api-client.ts";
import { useAuth } from "#app/hooks/use-auth.ts";
import { ExpenseFormSchema } from "#app/lib/schema.ts";

// 5. Relative imports (if necessary)
import { getExpenseById } from "./repository.ts";
```

### Path Aliases

**Apps use `#app/*` and `#api/*`:**

```json
// apps/app/package.json
{
  "imports": {
    "#app/*": "./src/*"
  }
}

// apps/api/package.json
{
  "imports": {
    "#api/*": "./src/*"
  }
}
```

**Packages use `#<package-name>/*`:**

```json
// packages/common/package.json
{
  "imports": {
    "#common/*": "./src/*"
  }
}
```

### TypeScript Conventions

**Function Components:**

```typescript
import type { ReactNode } from "react"

interface ButtonProps {
  children: ReactNode
  variant?: "primary" | "secondary"
  onClick?: () => void
}

export function Button({ children, variant = "primary", onClick }: ButtonProps) {
  return (
    <button onClick={onClick} className={cn("btn", `btn-${variant}`)}>
      {children}
    </button>
  )
}
```

**Custom Hooks:**

```typescript
export function useExpenses(workspaceId: string) {
  const { data, isLoading, error } = useQuery(
    getExpensesQueryOptions(workspaceId)
  );

  return { expenses: data ?? [], isLoading, error };
}
```

**Type Inference from Functions:**

```typescript
export function useExpenseLiveQuery() {
  // ... implementation
}

// Export inferred types
export type ExpensesClient = ReturnType<typeof useExpenseLiveQuery>;
export type ExpenseClient = ExpensesClient[number];
```

**Zod Schema Patterns:**

```typescript
// Define schema
export const ExpenseFormSchema = z.object({
  title: z.string().min(1),
  amount: z.coerce.number(), // Coerce string to number
  currency: CurrencySchema,
  date: z.iso.datetime(),
  walletId: z.uuidv7(),
  categoryId: z.uuidv7(),
  repeat: RepeatSchema,
});

// Infer TypeScript type
export type ExpenseFormSchema = z.infer<typeof ExpenseFormSchema>;

// Partial for updates
export const UpdateExpenseSchema = ExpenseFormSchema.partial();
```

**Hono RPC Client Types:**

```typescript
import type { InferRequestType, InferResponseType } from "hono/client";
import type { honoClient } from "#app/lib/api-client.ts";

// Infer response type
export type ExpenseSchema = InferResponseType<
  typeof honoClient.api.expenses.$get,
  200
>["data"][number];

// Infer request type
export type ExpensePostSchema = InferRequestType<
  typeof honoClient.api.expenses.$post
>["json"];
```

### Component Patterns

**Early Returns for Loading/Error States:**

```typescript
export function ExpenseList() {
  const expenses = useExpenseLiveQuery()

  if (!expenses.length) {
    return <EmptyState message="No expenses found" />
  }

  return (
    <div>
      {expenses.map((expense) => (
        <ExpenseItem key={expense.id} expense={expense} />
      ))}
    </div>
  )
}
```

**Compound Components:**

```typescript
export function ExpenseDetails({ expense }: { expense: ExpenseClient }) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{expense.title}</CardTitle>
        <CardDescription>{expense.category?.name}</CardDescription>
      </CardHeader>
      <CardContent>
        <CurrencyValue
          value={expense.amount}
          currency={expense.currency}
        />
      </CardContent>
      <CardFooter>
        <ExpenseActions expenseId={expense.id} />
      </CardFooter>
    </Card>
  )
}
```

### API Patterns

**Repository Functions:**

```typescript
// Always return typed results
export async function findMany(workspaceId: string): Promise<Expense[]> {
  return db
    .select()
    .from(expense)
    .where(eq(expense.workspaceId, workspaceId))
    .orderBy(desc(expense.date));
}

// Use transactions for multi-step operations
export async function createExpenseWithFiles(
  data: InsertExpense,
  files: File[]
) {
  return db.transaction(async (tx) => {
    const [expense] = await tx.insert(expenseTable).values(data).returning();

    if (files.length > 0) {
      await tx
        .insert(fileTable)
        .values(files.map((f) => ({ ...f, expenseId: expense.id })));
    }

    return expense;
  });
}
```

**Error Handling:**

```typescript
import { HTTPException } from "hono/http-exception";
import { HTTPStatus } from "@hoalu/common/http-status";

app.get("/expenses/:id", async (c) => {
  const expense = await repository.findById(c.req.param("id"));

  if (!expense) {
    throw new HTTPException(HTTPStatus.NOT_FOUND, {
      message: "Expense not found",
    });
  }

  return c.json({ data: expense });
});
```

**OpenAPI Documentation:**

```typescript
app.openapi(
  createRoute({
    method: "get",
    path: "/expenses",
    tags: ["expenses"],
    summary: "List expenses",
    request: {
      query: z.object({
        workspaceId: z.uuidv7(),
        limit: z.coerce.number().optional(),
      }),
    },
    responses: {
      200: {
        description: "List of expenses",
        content: {
          "application/json": {
            schema: z.object({
              data: z.array(ExpenseSchema),
            }),
          },
        },
      },
    },
  }),
  async (c) => {
    // Handler implementation
  }
);
```

## Environment Configuration

### Environment Variables

**API (`apps/api/.env`):**

```bash
# Database
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=hoalu

# Electric SQL
SYNC_URL=http://localhost:4000
SYNC_SECRET=your-sync-secret

# Better Auth
BETTER_AUTH_SECRET=your-auth-secret
BETTER_AUTH_URL=http://localhost:3000

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# S3 (optional)
S3_ENDPOINT=
S3_REGION=
S3_BUCKET=
S3_ACCESS_KEY=
S3_SECRET_KEY=

# Email (optional)
EMAIL_FROM=noreply@hoalu.app
SMTP_HOST=
SMTP_PORT=587
SMTP_USER=
SMTP_PASS=
```

**App (`apps/app/.env`):**

```bash
# API URL (via Caddy proxy)
PUBLIC_API_URL=http://api.hoalu.localhost

# App URL (via Caddy proxy)
PUBLIC_APP_BASE_URL=http://hoalu.localhost
```

**Note:** When using Caddy reverse proxy:

- Frontend runs on `localhost:5173` internally, served via Caddy at `hoalu.localhost`
- API runs on `localhost:3000` internally, served via Caddy at `api.hoalu.localhost`
- All browser requests go through Caddy for compression and optional HTTPS
- `.localhost` domains work natively without `/etc/hosts` modification

For HTTPS setup, change URLs to `https://hoalu.localhost` and `https://api.hoalu.localhost`

### Docker Services

**Infrastructure Stack:**

```yaml
# docker-compose.local.yml
services:
  postgres:
    image: postgres:17-alpine
    environment:
      POSTGRES_DB: hoalu
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    command:
      - -c
      - wal_level=logical # Required for Electric SQL
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  electric:
    image: electricsql/electric:latest
    environment:
      DATABASE_URL: postgres://postgres:postgres@postgres:5432/hoalu
      ELECTRIC_WRITE_TO_PG_MODE: logical_replication
      AUTH_MODE: secure
      AUTH_JWT_SECRET: ${SYNC_SECRET}
    ports:
      - "4000:4000"
    depends_on:
      - postgres
```

**Start Services:**

```bash
cd deployments
docker compose -f docker-compose.local.yml up -d
```

## Development Tips

### Working with the Monorepo

**Workspace References:**

```json
// Use workspace:* for internal packages
{
  "dependencies": {
    "@hoalu/common": "workspace:*",
    "@hoalu/ui": "workspace:*"
  }
}
```

**Shared Catalog:**

```json
// Root package.json - DRY for common versions
{
  "workspaces": {
    "catalog": {
      "react": "^19.2.0",
      "react-dom": "^19.2.0",
      "zod": "^4.1.12",
      "hono": "^4.10.4",
      "better-auth": "^1.3.34",
      "tailwindcss": "^4.1.16"
    }
  }
}

// Package references catalog
{
  "dependencies": {
    "react": "catalog:",
    "zod": "catalog:"
  }
}
```

**Turbo Build Pipeline:**

```json
// turbo.json
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"], // Build dependencies first
      "outputs": ["dist/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}
```

### Database Development

**Schema-First Workflow:**

1. Update `apps/api/src/db/schema.ts`
2. Generate migration: `bun run db:generate`
3. Review SQL in `apps/api/migrations/`
4. Apply migration: `bun run db:migrate`
5. Electric SQL picks up changes automatically

**Drizzle Query Patterns:**

```typescript
// Select with joins
const expensesWithWallet = await db
  .select({
    id: expense.id,
    title: expense.title,
    amount: expense.amount,
    walletName: wallet.name,
  })
  .from(expense)
  .innerJoin(wallet, eq(expense.walletId, wallet.id));

// Aggregation
const totalByCategory = await db
  .select({
    categoryId: expense.categoryId,
    total: sum(expense.amount),
  })
  .from(expense)
  .groupBy(expense.categoryId);

// Subqueries
const recentExpenses = db
  .select()
  .from(expense)
  .where(gt(expense.date, sql`NOW() - INTERVAL '30 days'`))
  .as("recent");

// Full-text search
const results = await db
  .select()
  .from(expense)
  .where(
    sql`to_tsvector('english', ${expense.title}) @@ plainto_tsquery('english', ${searchTerm})`
  );
```

### Frontend Development

**Hot Module Replacement:**

- Vite HMR with Fast Refresh
- Component updates without losing state
- CSS updates without page reload

**DevTools:**

```typescript
// Enable all DevTools in development
import { ReactQueryDevtools } from "@tanstack/react-query-devtools"
import { TanStackRouterDevtools } from "@tanstack/react-router-devtools"
import { TanStackFormDevtools } from "@tanstack/react-form-devtools"

function App() {
  return (
    <>
      {/* App content */}
      {import.meta.env.DEV && (
        <>
          <ReactQueryDevtools />
          <TanStackRouterDevtools />
        </>
      )}
    </>
  )
}
```

**Performance Optimization:**

```typescript
// Virtualized lists for large datasets
import { useVirtualizer } from "@tanstack/react-virtual"

function ExpenseList({ expenses }: { expenses: ExpenseClient[] }) {
  const parentRef = useRef<HTMLDivElement>(null)

  const virtualizer = useVirtualizer({
    count: expenses.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 78, // Estimate row height
    overscan: 5, // Render 5 extra items
  })

  return (
    <div ref={parentRef} className="h-full overflow-auto">
      <div style={{ height: virtualizer.getTotalSize() }}>
        {virtualizer.getVirtualItems().map((virtualRow) => (
          <ExpenseItem
            key={expenses[virtualRow.index].id}
            expense={expenses[virtualRow.index]}
            style={{
              transform: `translateY(${virtualRow.start}px)`,
            }}
          />
        ))}
      </div>
    </div>
  )
}
```

**Optimistic Updates:**

```typescript
export function useDeleteExpense() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string) => {
      await apiClient.api.expenses[":id"].$delete({ param: { id } });
    },
    onMutate: async (id) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ["expenses"] });

      // Snapshot previous value
      const previous = queryClient.getQueryData(["expenses"]);

      // Optimistically update
      queryClient.setQueryData<ExpenseSchema[]>(["expenses"], (old) =>
        old?.filter((e) => e.id !== id)
      );

      return { previous };
    },
    onError: (err, id, context) => {
      // Rollback on error
      queryClient.setQueryData(["expenses"], context?.previous);
    },
  });
}
```

### Testing & Quality

**Biome Configuration:**

```json
// biome.json
{
  "formatter": {
    "enabled": true,
    "indentStyle": "tab",
    "lineWidth": 100
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  }
}
```

**TypeScript Strict Mode:**
All packages use strict TypeScript:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true
  }
}
```

**Naming Conventions:**

- Components: `PascalCase` (ExpenseList.tsx)
- Hooks: `camelCase` with `use` prefix (useExpenses.ts)
- Utilities: `camelCase` (formatCurrency.ts)
- Types: `PascalCase` with Schema suffix (ExpenseFormSchema)
- Constants: `UPPER_SNAKE_CASE` (PG_ENUM_COLOR)
- Files: `kebab-case` or `PascalCase` for components

## Common Debugging

### Sync Issues

**Electric SQL Health Check:**

```bash
# Check Electric service
curl http://localhost:4000/health

# Verify WAL level
psql -h localhost -U postgres -d hoalu -c "SHOW wal_level;"
# Should return: logical
```

**Browser DevTools:**

```typescript
// Monitor shape subscriptions
window.addEventListener("electric:shape-sync", (e) => {
  console.log("Shape synced:", e.detail);
});

// Check PGlite database
const db = window.__pglite__;
await db.query("SELECT * FROM expense LIMIT 5");
```

**Common Issues:**

1. **Shape not updating**: Check `SYNC_SECRET` matches between API and Electric
2. **Auth errors**: Verify `fetchClient` includes credentials
3. **Stale data**: Clear PGlite IndexedDB: `indexedDB.deleteDatabase("idb://hoalu-db")`

### Database Issues

**Migration Troubleshooting:**

```bash
# Check migration status
cd apps/api
bun run drizzle-kit push

# Reset database (DANGER - deletes all data)
dropdb hoalu && createdb hoalu
bun run db:migrate
```

**Connection Pool:**

```typescript
// apps/api/src/db/index.ts
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";

const client = postgres(process.env.DATABASE_URL!, {
  max: 10, // Connection pool size
  idle_timeout: 20,
  connect_timeout: 10,
});

export const db = drizzle(client);
```

### Authentication Issues

**Session Debugging:**

```typescript
// Check session in API route
app.get("/debug/session", async (c) => {
  const session = await getSession(c);
  return c.json({ session, userId: session?.userId });
});
```

**Cookie Issues:**

```typescript
// Ensure credentials included in fetch
const res = await fetch("/api/expenses", {
  credentials: "include", // Required for cookies
});

// Check cookie settings
app.use("*", async (c, next) => {
  c.header("Access-Control-Allow-Credentials", "true");
  await next();
});
```

**Workspace Permissions:**

```typescript
// Verify member role
const member = await db.query.member.findFirst({
  where: and(
    eq(memberTable.workspaceId, workspaceId),
    eq(memberTable.userId, session.userId)
  ),
});

console.log("User role:", member?.role);
```

## Key Files Reference

**Configuration:**

- `/package.json` - Root workspace config
- `/turbo.json` - Turborepo pipeline
- `/biome.json` - Linting and formatting
- `/Caddyfile` - Reverse proxy configuration
- `/deployments/docker-compose.local.yml` - Local infrastructure

**API:**

- `/apps/api/src/app.ts` - Hono app setup
- `/apps/api/src/db/schema.ts` - Database schema (346 lines)
- `/apps/api/src/lib/auth.ts` - Better Auth configuration
- `/apps/api/src/modules/sync.ts` - Electric SQL proxy

**App:**

- `/apps/app/src/main.tsx` - React entry point
- `/apps/app/src/lib/api-client.ts` - Hono RPC client (8105 lines)
- `/apps/app/src/lib/schema.ts` - Frontend types (3127 lines)
- `/apps/app/src/hooks/use-db.ts` - Live query hooks
- `/apps/app/src/services/query-options.ts` - TanStack Query configs
- `/apps/app/src/services/mutations.ts` - Mutation configs

**Shared:**

- `/packages/common/src/schema.ts` - Shared Zod schemas
- `/packages/common/src/enums.ts` - Shared enum constants
- `/packages/common/src/datetime.ts` - Date utilities
- `/packages/common/src/monetary.ts` - Currency utilities

## Additional Notes

### Zod v4 Coercion

**`z.coerce.number()`** - Automatically converts string inputs to numbers:

```typescript
const schema = z.object({
  amount: z.coerce.number(), // "123" → 123
  quantity: z.coerce.number().int(), // "5" → 5
});

schema.parse({ amount: "123.45", quantity: "5" });
// → { amount: 123.45, quantity: 5 }
```

**Why it's used:**

- Electric SQL sends numeric values as strings for precision
- Zod coerces them back to JavaScript numbers
- Maintains type safety throughout the pipeline

### Import Paths

Always use the configured path aliases:

- ✅ `import { useAuth } from "#app/hooks/use-auth.ts"`
- ❌ `import { useAuth } from "../../hooks/use-auth.ts"`

### File Extensions

Always include `.ts` or `.tsx` extensions in imports:

- ✅ `import { schema } from "./schema.ts"`
- ❌ `import { schema } from "./schema"`

This is required for Bun and improves IDE support.

## Task Templates

### Template: Add New API Route

Use this template when adding a new resource endpoint (e.g., notes, tags, budgets).

**Steps:**

1. **Create route folder**: `apps/api/src/routes/[resource]/`

2. **Create three files** following the standard pattern:

   **File 1: `index.ts`** - HTTP handlers with OpenAPI docs
   ```typescript
   import { HTTPException } from "hono/http-exception";
   import { describeRoute } from "hono-openapi";
   import * as z from "zod";

   import { generateId } from "@hoalu/common/generate-id";
   import { HTTPStatus } from "@hoalu/common/http-status";
   import { OpenAPI } from "@hoalu/furnace";

   import { createHonoInstance } from "#api/lib/create-app.ts";
   import { workspaceMember } from "#api/middlewares/workspace-member.ts";
   import { [Resource]Repository } from "#api/routes/[resource]/repository.ts";
   import { Insert[Resource]Schema, [Resource]Schema } from "#api/routes/[resource]/schema.ts";
   import { idParamValidator } from "#api/validators/id-param.ts";
   import { jsonBodyValidator } from "#api/validators/json-body.ts";
   import { workspaceQueryValidator } from "#api/validators/workspace-query.ts";

   const app = createHonoInstance();
   const repository = new [Resource]Repository();
   const TAGS = ["[Resource]s"];

   // GET /api/[resource]s
   const route = app.get(
     "/",
     describeRoute({ tags: TAGS, summary: "Get all [resource]s" }),
     workspaceQueryValidator,
     workspaceMember,
     async (c) => {
       const workspace = c.get("workspace");
       const data = await repository.findAllByWorkspaceId({ workspaceId: workspace.id });
       return c.json({ data }, HTTPStatus.codes.OK);
     }
   );

   // POST /api/[resource]s
   // PATCH /api/[resource]s/:id
   // DELETE /api/[resource]s/:id
   // ... add other CRUD operations

   export default route;
   ```

   **File 2: `repository.ts`** - Database operations
   ```typescript
   import { and, desc, eq } from "drizzle-orm";

   import { db, schema } from "#api/db/index.ts";

   type New[Resource] = typeof schema.[resource].$inferInsert;

   export class [Resource]Repository {
     async findAllByWorkspaceId(param: { workspaceId: string }) {
       return db
         .select()
         .from(schema.[resource])
         .where(eq(schema.[resource].workspaceId, param.workspaceId))
         .orderBy(desc(schema.[resource].createdAt));
     }

     async findOne(param: { id: string; workspaceId: string }) {
       const [result] = await db
         .select()
         .from(schema.[resource])
         .where(
           and(
             eq(schema.[resource].id, param.id),
             eq(schema.[resource].workspaceId, param.workspaceId)
           )
         );
       return result || null;
     }

     async insert(param: New[Resource]) {
       try {
         const [result] = await db.insert(schema.[resource]).values(param).returning();
         return result;
       } catch (_error) {
         return null;
       }
     }

     async update<T>(param: { id: string; workspaceId: string; payload: T }) {
       try {
         const [result] = await db
           .update(schema.[resource])
           .set({ ...param.payload, updatedAt: new Date() })
           .where(
             and(
               eq(schema.[resource].id, param.id),
               eq(schema.[resource].workspaceId, param.workspaceId)
             )
           )
           .returning();
         return result || null;
       } catch (_error) {
         return null;
       }
     }

     async delete(param: { id: string; workspaceId: string }) {
       await db
         .delete(schema.[resource])
         .where(
           and(
             eq(schema.[resource].id, param.id),
             eq(schema.[resource].workspaceId, param.workspaceId)
           )
         );
       return { id: param.id };
     }
   }
   ```

   **File 3: `schema.ts`** - Zod validation schemas
   ```typescript
   import * as z from "zod";

   export const Insert[Resource]Schema = z.object({
     title: z.string().min(1),
     description: z.string().optional(),
     workspaceId: z.uuidv7(),
     // Add other fields
   });

   export const Update[Resource]Schema = Insert[Resource]Schema.partial();

   export const [Resource]Schema = z.object({
     id: z.uuidv7(),
     title: z.string(),
     description: z.string().nullable(),
     workspaceId: z.uuidv7(),
     createdAt: z.string(),
     updatedAt: z.string(),
   });

   export const [Resource]sSchema = z.array([Resource]Schema);

   export const Delete[Resource]Schema = z.object({
     id: z.uuidv7(),
   });
   ```

3. **Add table to database schema**: `apps/api/src/db/schema.ts`
   ```typescript
   export const [resource] = pgTable(
     "[resource]",
     {
       id: uuid("id").primaryKey(),
       title: text("title").notNull(),
       description: text("description"),
       workspaceId: uuid("workspace_id")
         .notNull()
         .references(() => workspace.id, { onDelete: "cascade" }),
       createdAt: timestamp("created_at").defaultNow().notNull(),
       updatedAt: timestamp("updated_at").defaultNow().notNull(),
     },
     (table) => [
       index("[resource]_workspace_id_idx").on(table.workspaceId),
     ]
   );
   ```

4. **Generate and apply migration**:
   ```bash
   cd apps/api
   bun run db:generate  # Creates migration file
   bun run db:migrate   # Applies migration
   ```

5. **Register route in API module**: `apps/api/src/modules/api.ts`
   ```typescript
   import [resource]Route from "#api/routes/[resource]/index.ts";

   // In the module function:
   app.route("/api/[resource]s", [resource]Route);
   ```

6. **Test the endpoints**:
   ```bash
   # Start dev server
   bun run dev

   # Test API
   curl http://api.hoalu.localhost/api/[resource]s?workspaceId=xxx
   ```

**Example:** See `apps/api/src/routes/expenses/` for complete reference implementation.

---

### Template: Add Frontend Feature

Use this template when adding a new feature to the frontend (e.g., notes, tags, budgets).

**Steps:**

1. **Create Electric SQL collection**: `apps/app/src/lib/collections/[resource].ts`
   ```typescript
   import { electricCollectionOptions } from "@tanstack/electric-db-collection";
   import { createCollection } from "@tanstack/react-db";
   import * as z from "zod";

   import { IsoDateSchema } from "@hoalu/common/schema";

   export const Select[Resource]Schema = z.object({
     id: z.uuidv7(),
     title: z.string(),
     description: z.string().nullable(),
     workspace_id: z.uuidv7(),
     created_at: IsoDateSchema,
     updated_at: IsoDateSchema,
   });

   export const [resource]Collection = (workspaceId: string) => {
     return createCollection(
       electricCollectionOptions({
         getKey: (item) => item.id,
         schema: Select[Resource]Schema,
         shapeOptions: {
           url: new URL(`${import.meta.env.PUBLIC_API_URL}/sync`).toString(),
           params: {
             table: "[resource]",
             where: "workspace_id = $1",
             params: [workspaceId],
           },
           fetchClient: (req, init) =>
             fetch(req, { ...init, credentials: "include" }),
         },
       })
     );
   };
   ```

2. **Create custom hook**: `apps/app/src/components/[resource]/use-[resource].ts`
   ```typescript
   import { eq, useLiveQuery } from "@tanstack/react-db";
   import { useAtom } from "jotai";
   import { useMemo } from "react";

   import { datetime } from "@hoalu/common/datetime";

   import { selected[Resource]Atom } from "#app/atoms/[resource].ts";
   import { useWorkspace } from "#app/hooks/use-workspace.ts";
   import { [resource]Collection } from "#app/lib/collections/[resource].ts";

   export function useSelected[Resource]() {
     const [[resource], setSelected[Resource]] = useAtom(selected[Resource]Atom);
     const onSelect[Resource] = (id: string | null) => {
       setSelected[Resource]({ id });
     };
     return { [resource], onSelect[Resource] };
   }

   export function useLiveQuery[Resource]s() {
     const workspace = useWorkspace();

     const { data } = useLiveQuery(
       (q) => {
         return q
           .from({ [resource]: [resource]Collection(workspace.id) })
           .orderBy(({ [resource] }) => [resource].created_at, "desc")
           .select(({ [resource] }) => ({ ...[resource] }));
       },
       [workspace.id]
     );

     const transformed = useMemo(() => {
       if (!data) return [];
       return data.map(([resource]) => ({
         ...[resource],
         createdAt: datetime.format([resource].created_at, "yyyy-MM-dd HH:mm"),
       }));
     }, [data]);

     return transformed;
   }

   export type Synced[Resource]s = ReturnType<typeof useLiveQuery[Resource]s>;
   export type Synced[Resource] = Synced[Resource]s[number];
   ```

3. **Create components**:
   - `[resource]-list.tsx` - List view with virtualization
   - `[resource]-details.tsx` - Detail panel
   - `[resource]-actions.tsx` - CRUD dialogs/buttons
   - `[resource]-filter.tsx` (optional) - Filter controls

4. **Create atoms**: `apps/app/src/atoms/[resource].ts`
   ```typescript
   import { atom } from "jotai";

   export const selected[Resource]Atom = atom<{ id: string | null }>({ id: null });
   export const [resource]DialogAtom = atom(false);
   ```

5. **Create route**: `apps/app/src/routes/_dashboard/$slug/[resource]s.tsx`
   ```typescript
   import { createFileRoute } from "@tanstack/react-router";

   import { useLiveQuery[Resource]s } from "#app/components/[resource]/use-[resource].ts";
   import { [Resource]List } from "#app/components/[resource]/[resource]-list.tsx";
   import { [Resource]Details } from "#app/components/[resource]/[resource]-details.tsx";
   import { Create[Resource]DialogTrigger } from "#app/components/[resource]/[resource]-actions.tsx";
   import { Section, SectionContent, SectionHeader, SectionTitle } from "#app/components/layouts/section.tsx";

   export const Route = createFileRoute("/_dashboard/$slug/[resource]s")({
     component: RouteComponent,
   });

   function RouteComponent() {
     const [resource]s = useLiveQuery[Resource]s();

     return (
       <Section>
         <SectionHeader>
           <SectionTitle>[Resource]s</SectionTitle>
           <Create[Resource]DialogTrigger />
         </SectionHeader>
         <SectionContent columns={12}>
           <[Resource]List [resource]s={[resource]s} />
           <[Resource]Details />
         </SectionContent>
       </Section>
     );
   }
   ```

6. **Add mutations**: `apps/app/src/services/mutations.ts`
   ```typescript
   export function useCreate[Resource]() {
     const queryClient = useQueryClient();

     return useMutation({
       mutationFn: async (data: Insert[Resource]Schema) => {
         const res = await apiClient.api.[resource]s.$post({ json: data });
         if (!res.ok) throw new Error("Failed to create [resource]");
         return res.json();
       },
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: ["[resource]s"] });
       },
     });
   }
   ```

**Example:** See `apps/app/src/components/expenses/` for complete reference implementation.

---

### Template: Add Database Migration

Use this when modifying the database schema (adding columns, tables, indexes, etc.).

**Steps:**

1. **Modify schema**: Edit `apps/api/src/db/schema.ts`
   ```typescript
   // Example: Add a new column
   export const expense = pgTable("expense", {
     // ... existing columns
     tags: text("tags").array().default([]),  // New column
   });
   ```

2. **Generate migration**:
   ```bash
   cd apps/api
   bun run db:generate
   # This creates a new file in apps/api/migrations/
   ```

3. **Review migration SQL**:
   - Check generated SQL in `apps/api/migrations/XXXX_*.sql`
   - Ensure it matches your intent
   - Add custom SQL if needed (e.g., data migrations)

4. **Apply migration**:
   ```bash
   bun run db:migrate
   ```

5. **Verify Electric SQL sync**:
   ```bash
   # Check Electric service
   curl http://localhost:4000/health

   # Restart Electric if needed
   bun run docker:down
   bun run docker:up
   ```

6. **Update frontend collection schema** if needed:
   ```typescript
   // apps/app/src/lib/collections/expense.ts
   export const SelectExpenseSchema = z.object({
     // ... existing fields
     tags: z.array(z.string()).default([]),  // Add new field
   });
   ```

**Common Pitfall:** Always restart Electric SQL service after schema changes that affect synced tables.

---

### Complete Example: Expenses Feature

This is a real implementation from the codebase showing all pieces working together.

**API Structure:**
```
apps/api/src/routes/expenses/
├── index.ts (251 lines)      # GET, POST, PATCH, DELETE endpoints
├── repository.ts (90 lines)  # ExpenseRepository with CRUD methods
└── schema.ts                 # InsertExpenseSchema, UpdateExpenseSchema, ExpenseSchema
```

**Frontend Structure:**
```
apps/app/src/components/expenses/
├── expense-list.tsx          # Virtualized list (TanStack Virtual)
├── expense-content.tsx       # Individual list item
├── expense-details.tsx       # Detail panel with edit/delete
├── expense-actions.tsx       # Create/Edit dialog triggers
├── expense-filter.tsx        # Search + category/wallet/repeat filters
└── use-expenses.ts (253)     # useLiveQueryExpenses, useExpenseStats, filtering
```

**Key Implementation Details:**

1. **Live Query with Joins** (`use-expenses.ts:155-200`):
   ```typescript
   export function useLiveQueryExpenses() {
     const workspace = useWorkspace();

     const { data } = useLiveQuery((q) =>
       q.from({ expense: expenseCollection(workspace.id) })
         .innerJoin({ wallet: walletCollection(workspace.id) },
           ({ expense, wallet }) => eq(expense.wallet_id, wallet.id))
         .leftJoin({ category: categoryCollection(workspace.id) },
           ({ expense, category }) => eq(expense.category_id, category.id))
         .orderBy(({ expense }) => expense.date, "desc")
         .select(({ expense, wallet, category }) => ({
           ...expense,
           category: { id: category?.id, name: category?.name, color: category?.color },
           wallet: { id: wallet.id, name: wallet.name, type: wallet.type }
         }))
     );

     return useMemo(() => {
       if (!data) return [];
       return data.map((expense) => ({
         ...expense,
         date: datetime.format(expense.date, "yyyy-MM-dd"),
         amount: monetary.fromRealAmount(Number(expense.amount), expense.currency),
       }));
     }, [data]);
   }
   ```

2. **Repository with Joins** (`repository.ts:8-26`):
   ```typescript
   async findAllByWorkspaceId(param: { workspaceId: string }) {
     const queryData = await db
       .select()
       .from(schema.expense)
       .innerJoin(schema.user, eq(schema.expense.creatorId, schema.user.id))
       .innerJoin(schema.wallet, eq(schema.expense.walletId, schema.wallet.id))
       .leftJoin(schema.category, eq(schema.expense.categoryId, schema.category.id))
       .where(eq(schema.expense.workspaceId, param.workspaceId))
       .orderBy(desc(schema.expense.date), desc(schema.expense.amount));

     return queryData.map((data) => ({
       ...data.expense,
       creator: data.user,
       wallet: data.wallet,
       category: data.category,
     }));
   }
   ```

3. **Route with Middleware** (`index.ts:30-61`):
   ```typescript
   app.get(
     "/",
     describeRoute({ tags: TAGS, summary: "Get all expenses" }),
     workspaceQueryValidator,  // Validates ?workspaceId
     workspaceMember,          // Checks user is member
     async (c) => {
       const workspace = c.get("workspace");
       const expenses = await expenseRepository.findAllByWorkspaceId({
         workspaceId: workspace.id
       });
       return c.json({ data: expenses }, HTTPStatus.codes.OK);
     }
   );
   ```

**Learn by Example:** Study the expenses implementation to understand patterns, then apply to new features.
